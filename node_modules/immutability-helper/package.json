{
  "_args": [
    [
      {
        "raw": "immutability-helper@2.6.5",
        "scope": null,
        "escapedName": "immutability-helper",
        "name": "immutability-helper",
        "rawSpec": "2.6.5",
        "spec": "2.6.5",
        "type": "version"
      },
      "/Users/gom/Desktop/2018-02-20"
    ]
  ],
  "_from": "immutability-helper@2.6.5",
  "_id": "immutability-helper@2.6.5",
  "_inCache": true,
  "_location": "/immutability-helper",
  "_nodeVersion": "9.4.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/immutability-helper_2.6.5_1518736549757_0.18095947103917398"
  },
  "_npmUser": {
    "name": "andreiglingeanu",
    "email": "andrei.glingeanu@gmail.com"
  },
  "_npmVersion": "5.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "immutability-helper@2.6.5",
    "scope": null,
    "escapedName": "immutability-helper",
    "name": "immutability-helper",
    "rawSpec": "2.6.5",
    "spec": "2.6.5",
    "type": "version"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/immutability-helper/-/immutability-helper-2.6.5.tgz",
  "_shasum": "94a10f18f1196244b2dea92d46522d2b4dce7b73",
  "_shrinkwrap": null,
  "_spec": "immutability-helper@2.6.5",
  "_where": "/Users/gom/Desktop/2018-02-20",
  "author": {
    "name": "Moshe Kolodny"
  },
  "bugs": {
    "url": "https://github.com/kolodny/immutability-helper/issues"
  },
  "dependencies": {
    "invariant": "^2.2.0"
  },
  "description": "mutate a copy of data without changing the original source",
  "devDependencies": {
    "coveralls": "^2.11.6",
    "dtslint": "^0.2.0",
    "expect": "^1.14.0",
    "mocha": "^2.4.5",
    "nyc": "^5.6.0"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-nRj5RN2em1O3NK25Zz0eBszg+kQ3mR5WgZp3wRajbyeu/Ii/eXhpwjB8JG4Hd78JUnuFVXSchWF5EZBI6F+vEA==",
    "shasum": "94a10f18f1196244b2dea92d46522d2b4dce7b73",
    "tarball": "https://registry.npmjs.org/immutability-helper/-/immutability-helper-2.6.5.tgz",
    "fileCount": 10,
    "unpackedSize": 40430
  },
  "gitHead": "3f797c9da0a7a9caa1f4ae1920f0f2fe3ed5b6a8",
  "homepage": "https://github.com/kolodny/immutability-helper#readme",
  "keywords": [
    "immutability"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "andreiglingeanu",
      "email": "andrei.glingeanu@gmail.com"
    },
    {
      "name": "kolodny",
      "email": "kolodny.github@gmail.com"
    }
  ],
  "name": "immutability-helper",
  "optionalDependencies": {},
  "readme": "immutability-helper\n===\n\n[![NPM version][npm-image]][npm-url]\n[![Build status][travis-image]][travis-url]\n[![Test coverage][coveralls-image]][coveralls-url]\n[![Downloads][downloads-image]][downloads-url]\n\nMutate a copy of data without changing the original source\n\nSetup via NPM\n```sh\nnpm install immutability-helper --save\n```\n\nThis is a drop-in replacement for [`react-addons-update`](https://facebook.github.io/react/docs/update.html):\n```js\n// import update from 'react-addons-update';\nimport update from 'immutability-helper';\n\nconst state1 = ['x'];\nconst state2 = update(state1, {$push: ['y']}); // ['x', 'y']\n```\n\nNote that this module has nothing to do with React. However, since this module\nis most commonly used with React, the docs will focus on how it can be used with\nReact.\n\n## Overview\n\nReact lets you use whatever style of data management you want, including\nmutation. However, if you can use immutable data in performance-critical parts\nof your application it's easy to implement a fast[`shouldComponentUpdate()`](https://facebook.github.io/react/docs/react-component.html#shouldcomponentupdate) method\nto significantly speed up your app.\n\nDealing with immutable data in JavaScript is more difficult than in languages\ndesigned for it, like [Clojure](http://clojure.org/). However, we've provided a\nsimple immutability helper, `update()`, that makes dealing with this type of\ndata much easier, *without* fundamentally changing how your data is represented.\nYou can also take a look at Facebook's\n[Immutable.js](https://facebook.github.io/immutable-js/docs/) and Reactâ€™s\n[Using Immutable Data Structures](https://facebook.github.io/react/docs/optimizing-performance.html#using-immutable-data-structures) section for more\ndetail on Immutable.js.\n\n### The Main Idea\n\nIf you mutate data like this:\n\n```js\nmyData.x.y.z = 7;\n// or...\nmyData.a.b.push(9);\n```\n\nYou have no way of determining which data has changed since the previous copy\nhas been overwritten. Instead, you need to create a new copy of `myData` and\nchange only the parts of it that need to be changed. Then you can compare the\nold copy of `myData` with the new one in `shouldComponentUpdate()` using\ntriple-equals:\n\n```js\nconst newData = deepCopy(myData);\nnewData.x.y.z = 7;\nnewData.a.b.push(9);\n```\n\nUnfortunately, deep copies are expensive, and sometimes impossible. You can\nalleviate this by only copying objects that need to be changed and by reusing\nthe objects that haven't changed. Unfortunately, in today's JavaScript this can\nbe cumbersome:\n\n```js\nconst newData = extend(myData, {\n  x: extend(myData.x, {\n    y: extend(myData.x.y, {z: 7}),\n  }),\n  a: extend(myData.a, {b: myData.a.b.concat(9)})\n});\n```\n\nWhile this is fairly performant (since it only makes a shallow copy of `log n`\nobjects and reuses the rest), it's a big pain to write. Look at all the\nrepetition! This is not only annoying, but also provides a large surface area\nfor bugs.\n\n## `update()`\n\n`update()` provides simple syntactic sugar around this pattern to make writing\nthis code easier. This code becomes:\n\n```js\nimport update from 'immutability-helper';\n\nconst newData = update(myData, {\n  x: {y: {z: {$set: 7}}},\n  a: {b: {$push: [9]}}\n});\n```\n\nWhile the syntax takes a little getting used to (though it's inspired by\n[MongoDB's query language](http://docs.mongodb.org/manual/core/crud-introduction/#query)) there's no redundancy, it's statically analyzable and it's not much more typing\nthan the mutative version.\n\nThe `$`-prefixed keys are called *commands*. The data structure they are\n\"mutating\" is called the *target*.\n\n## Available Commands\n\n  * `{$push: array}` `push()` all the items in `array` on the target.\n  * `{$unshift: array}` `unshift()` all the items in `array` on the target.\n  * `{$splice: array of arrays}` for each item in `arrays` call `splice()` on\n  the target with the parameters provided by the item. ***Note:** The items in\n  the array are applied sequentially, so the order matters. The indices of the\n  target may change during the operation.*\n  * `{$set: any}` replace the target entirely.\n  * `{$toggle: array of strings}` toggles a list of boolean fields from the\n  target object.\n  * `{$unset: array of strings}` remove the list of keys in `array` from the\n  target object.\n  * `{$merge: object}` merge the keys of `object` with the target.\n  * `{$apply: function}` passes in the current value to the function and\n  updates it with the new returned value.\n  * `{$add: array of objects}` add a value to a `Map` or `Set`. When adding to a\n  `Set` you pass in an array of objects to add, when adding to a Map, you pass\n  in `[key, value]` arrays like so:\n  `update(myMap, {$add: [['foo', 'bar'], ['baz', 'boo']]})`\n  * `{$remove: array of strings}` remove the list of keys in array from a `Map`\n  or `Set`.\n\n### Shorthand `$apply` syntax\n\nAdditionally, instead of a command object, you can pass a function, and it will\nbe treated as if it was a command object with the `$apply` command:\n`update({a: 1}, {a: function})`. That example would be equivalent to\n`update({a: 1}, {a: {$apply: function}})`.\n\n## Examples\n\n### Simple push\n\n```js\nconst initialArray = [1, 2, 3];\nconst newArray = update(initialArray, {$push: [4]}); // => [1, 2, 3, 4]\n```\n`initialArray` is still `[1, 2, 3]`.\n\n### Nested collections\n\n```js\nconst collection = [1, 2, {a: [12, 17, 15]}];\nconst newCollection = update(collection, {2: {a: {$splice: [[1, 1, 13, 14]]}}});\n// => [1, 2, {a: [12, 13, 14, 15]}]\n```\nThis accesses `collection`'s index `2`, key `a`, and does a splice of one item\nstarting from index `1` (to remove `17`) while inserting `13` and `14`.\n\n### Updating a value based on its current one\n\n```js\nconst obj = {a: 5, b: 3};\nconst newObj = update(obj, {b: {$apply: function(x) {return x * 2;}}});\n// => {a: 5, b: 6}\n// This is equivalent, but gets verbose for deeply nested collections:\nconst newObj2 = update(obj, {b: {$set: obj.b * 2}});\n```\n\n### (Shallow) Merge\n\n```js\nconst obj = {a: 5, b: 3};\nconst newObj = update(obj, {$merge: {b: 6, c: 7}}); // => {a: 5, b: 6, c: 7}\n```\n\n### Computed Property Names\n\nArrays can be indexed into with runtime variables via the ES2015\n[Computed Property Names](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names)\nfeature. An object property name expression may be wrapped in brackets [] which\nwill be evaluated at runtime to form the final property name.\n\n```js\nconst collection = {children: ['zero', 'one', 'two']};\nconst index = 1;\nconst newCollection = update(collection, {children: {[index]: {$set: 1}}});\n// => {children: ['zero', 1, 'two']}\n```\n\n### [Autovivification](https://en.wikipedia.org/wiki/Autovivification)\n\nAutovivification is the auto creation of new arrays and objects when needed. In\nthe context of javascript that would mean something like this\n\n```js\nconst state = {}\nstate.a.b.c = 1; // state would equal { a: { b: { c: 1 } } }\n```\n\nSince javascript doesn't have this \"feature\", the same applies to\n`immutability-helper`. The reason why this is practically impossible in\njavascript and by extension `immutability-helper` is the following:\n\n```js\nvar state = {}\nstate.thing[0] = 'foo' // What type should state.thing have? Should it be an object or array?\nstate.thing2[1] = 'foo2' // What about thing2? This must be an object!\nstate.thing3 = ['thing3'] // This is regular js, this works without autovivification\nstate.thing3[1] = 'foo3' // Hmm, notice that state.thing2 is an object, yet this is an array\nstate.thing2.slice // should be undefined\nstate.thing2.slice // should be a function\n```\n\nIf you need to set something deeply nested and don't want to have to set each\nlayer down the line, consider using this technique which is shown with a\ncontrived example:\n\n```js\nvar state = {}\nvar desiredState = {\n  foo: [\n    {\n      bar: ['x', 'y', 'z']\n    },\n  ],\n};\n\nconst state2 = update(state, {\n  foo: foo =>\n    update(foo || [], {\n      0: fooZero =>\n        update(fooZero || {}, {\n          bar: bar => update(bar || [], { $push: [\"x\", \"y\", \"z\"] })\n        })\n    })\n});\n\nconsole.log(JSON.stringify(state2) === JSON.stringify(desiredState)) // true\n// note that state could have been declared as any of the following and it would still output true:\n// var state = { foo: [] }\n// var state = { foo: [ {} ] }\n// var state = { foo: [ {bar: []} ] }\n```\n\nYou can also choose to use the extend functionality to add an `$auto` and\n`$autoArray` command:\n\n```js\nupdate.extend('$auto', function(value, object) {\n  return object ?\n    update(object, value):\n    update({}, value);\n});\nupdate.extend('$autoArray', function(value, object) {\n  return object ?\n    update(object, value):\n    update([], value);\n});\n\nvar state = {}\nvar desiredState = {\n  foo: [\n    {\n      bar: ['x', 'y', 'z']\n    },\n  ],\n};\nvar state2 = update(state, {\n  foo: {$autoArray: {\n    0: {$auto: {\n      bar: {$autoArray: {$push: ['x', 'y', 'z']}}\n    }}\n  }}\n});\nconsole.log(JSON.stringify(state2) === JSON.stringify(desiredState)) // true\n```\n\n---\n\n## Adding your own commands\n\nThe main difference this module has with `react-addons-update` is that\nyou can extend this to give it more functionality:\n\n```js\nupdate.extend('$addtax', function(tax, original) {\n  return original + (tax * original);\n});\nconst state = { price: 123 };\nconst withTax = update(state, {\n  price: {$addtax: 0.8},\n});\nassert(JSON.stringify(withTax) === JSON.stringify({ price: 221.4 }));\n```\n\nNote that `original` in the function above is the original object, so if you\nplan making a mutation, you must first shallow clone the object. Another option\nis to use `update` to make the change\n`return update(original, { foo: {$set: 'bar'} })`\n\nIf you don't want to mess around with the globally exported `update` function\nyou can make a copy and work with that copy:\n\n```js\nimport { newContext } from 'immutability-helper';\nconst myUpdate = newContext();\nmyUpdate.extend('$foo', function(value, original) {\n  return 'foo!';\n});\n```\n\n[npm-image]: https://img.shields.io/npm/v/immutability-helper.svg?style=flat-square\n[npm-url]: https://npmjs.org/package/immutability-helper\n[travis-image]: https://img.shields.io/travis/kolodny/immutability-helper.svg?style=flat-square\n[travis-url]: https://travis-ci.org/kolodny/immutability-helper\n[coveralls-image]: https://img.shields.io/coveralls/kolodny/immutability-helper.svg?style=flat-square\n[coveralls-url]: https://coveralls.io/r/kolodny/immutability-helper\n[downloads-image]: http://img.shields.io/npm/dm/immutability-helper.svg?style=flat-square\n[downloads-url]: https://npmjs.org/package/immutability-helper\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/kolodny/immutability-helper.git"
  },
  "scripts": {
    "node-gt4": "node -e 'process.exit(/v(\\d+)/.exec(process.version)[1] <= 4) ? 1 : 0'",
    "test": "mocha test.js",
    "test-cov": "nyc npm test && nyc report --reporter=lcov",
    "test-dtslint": "npm run node-gt4 && dtslint || true",
    "test-travis": "npm run test-dtslint && nyc npm test && nyc report --reporter=lcov"
  },
  "typings": "index.d.ts",
  "version": "2.6.5"
}
